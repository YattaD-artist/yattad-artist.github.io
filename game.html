<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Thử Nghiệm</title>

  <!-- Bộ font và logo -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="style.css">
  
  <style>

    .background {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-image: url('assets/Dat.png');
      background-size: 98px 98px;
      opacity: 0.3;
      z-index: 0;
      pointer-events: none;
    }

    a {
      display: inline-block;
      margin-top: 32px;
      font-family: 'Patrick Hand', cursive;
      font-size: clamp(1.1rem, 2vw, 1.6rem);
      text-decoration: none;
      color: #000;
      transition: color 0.2s ease, transform 0.2s ease;
    }

   a.back-link {
  display: inline-block;
  margin-top: 32px;
  font-family: 'Patrick Hand', cursive;
  font-size: clamp(1.1rem, 2vw, 1.6rem);
  text-decoration: none;
  color: #111;
  transition: color 0.2s ease, transform 0.2s ease;
}

a:hover {
  color: #dc3849;
  transform: scale(1.1);
}


    #character {
      width: 62px;
      height: 62px;
      position: absolute;
      image-rendering: pixelated;
      pointer-events: none;
      z-index: 5;
      left: 4vw;
    }

    .instruction {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Noto Sans', sans-serif;
      font-size: clamp(1rem, 2vw, 1.4rem);
      color: rgba(50, 50, 50, 0.4);
      background: rgba(255, 255, 255, 0.3);
      padding: 6px 12px;
      border-radius: 8px;
      z-index: 10;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }

    .instruction.hidden {
      opacity: 0;
    }

  </style>
</head>

<body>
  <div class="background"></div>
 
 <a href="index.html">← Quay lại trang chủ</a>
  </div>
  
  <img id="character" src="assets/character/Idle/Idle00.png" alt="Vydra" />

  <div class="instruction" id="instruction">
    ⬅️ ⬆️ ⬇️ ➡️ để di chuyển · Giữ phím <kbd>Space</kbd> để chạy
  </div>

  <script>
    const character = document.getElementById('character');
    const instruction = document.getElementById('instruction');
    const frameSize = 62;
    const textContainer = document.getElementById('text-container');
    let pos = {
      x: window.innerWidth * 0.04, // nhân vật ở bên trái
      y: textContainer.getBoundingClientRect().bottom + 20
    };

    let direction = '';
    let moveFrame = 0;
    let idleFrame = 0;
    let state = 'idle';
    let spacePressed = false;
    let lastDirection = '';
    const keysHeld = new Set();
    let instructionHidden = false;

    const speedPerFrame = {
      walk: 2,
      run: 4
    };

    const frameRates = {
      idle: 200,
      walk: 100,
      run: 80
    };

    const keyToVector = {
      'ArrowUp':    { dx: 0, dy: -1, dir: 'U' },
      'ArrowDown':  { dx: 0, dy: 1,  dir: '' },
      'ArrowLeft':  { dx: -1, dy: 0, dir: 'L' },
      'ArrowRight': { dx: 1, dy: 0,  dir: 'R' }
    };

    const preloadImages = (callback) => {
      const folders = { Idle: 16, Walk: 16, Run: 8 };
      const directions = ['', 'U', 'L', 'R'];
      let loaded = 0;
      let total = 0;

      for (const folder in folders) {
        for (const dir of directions) {
          const count = folders[folder];
          for (let i = 0; i < count; i++) {
            const frameStr = folder === 'Run' ? `${i}` : i.toString().padStart(2, '0');
            const src = `assets/character/${folder}/${folder}${dir}${frameStr}.png`;
            const img = new Image();
            img.src = src;
            img.onload = img.onerror = () => {
              loaded++;
              if (loaded === total) callback();
            };
            total++;
          }
        }
      }
    };
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast(`Đã sao chép: ${text}`);
  });
}

function showToast(message) {
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.style.opacity = 1;
  setTimeout(() => {
    toast.style.opacity = 0;
  }, 2000);
}

    const updateSprite = () => {
      const folder = state.charAt(0).toUpperCase() + state.slice(1);
      const baseName = folder + direction;
      const frameStr = (state === 'run') ? `${moveFrame % 8}` :
                       (state === 'idle' ? idleFrame : moveFrame % 16).toString().padStart(2, '0');
      character.src = `assets/character/${folder}/${baseName}${frameStr}.png`;
    };

    let lastFrameTime = 0;
    let animTimer = 0;

    const gameLoop = (timestamp) => {
      const delta = timestamp - lastFrameTime;
      lastFrameTime = timestamp;
      animTimer += delta;

      let moved = false;
      let dx = 0, dy = 0;

      for (let key of keysHeld) {
        if (keyToVector[key]) {
          const vec = keyToVector[key];
          dx = vec.dx;
          dy = vec.dy;
          direction = vec.dir;
          lastDirection = direction;
          moved = true;
          break;
        }
      }

      if (moved) {
        if (!instructionHidden) {
          instruction.classList.add('hidden');
          instructionHidden = true;
        }

        state = spacePressed ? 'run' : 'walk';
        const speed = speedPerFrame[state];
        pos.x += dx * speed;
        pos.y += dy * speed;
        character.style.left = pos.x + 'px';
        character.style.top = pos.y + 'px';

        const frameInterval = frameRates[state];
        if (animTimer >= frameInterval) {
          moveFrame++;
          updateSprite();
          animTimer = 0;
        }
      } else {
        state = 'idle';
        direction = lastDirection;
        if (animTimer >= frameRates.idle) {
          idleFrame = (idleFrame + 1) % 16;
          updateSprite();
          animTimer = 0;
        }
      }

      requestAnimationFrame(gameLoop);
    };

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') spacePressed = true;
      if (keyToVector[e.key]) {
        keysHeld.add(e.key);
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space') spacePressed = false;
      if (keyToVector[e.key]) {
        keysHeld.delete(e.key);
        e.preventDefault();
      }
    });

    character.style.left = pos.x + 'px';
    character.style.top = pos.y + 'px';

    preloadImages(() => {
      updateSprite();
      requestAnimationFrame(gameLoop);
    });

function showToast(message) {
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.classList.add('show');

  // Tự ẩn sau 2s
  setTimeout(() => {
    toast.classList.remove('show');
  }, 2000);
}


  </script>
</body>
</html>
